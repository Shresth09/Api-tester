import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.http.*;
import org.springframework.web.client.RestTemplate;

import java.util.*;

public class JiraCustomFieldService {

    private final RestTemplate restTemplate;
    private final ObjectMapper objectMapper;
    private final String jiraToken;
    private final String jiraBaseUrl;

    public JiraCustomFieldService(RestTemplate restTemplate, ObjectMapper objectMapper, String jiraToken, String jiraBaseUrl) {
        this.restTemplate = restTemplate;
        this.objectMapper = objectMapper;
        this.jiraToken = jiraToken;
        this.jiraBaseUrl = jiraBaseUrl;
    }

    public Map<String, String> fetchIssueCustomFieldMap(String issueKey) throws Exception {
        HttpHeaders headers = new HttpHeaders();
        headers.set("Authorization", "Bearer " + jiraToken);
        headers.set("Accept", MediaType.APPLICATION_JSON_VALUE);
        HttpEntity<String> entity = new HttpEntity<>(headers);

        String url = jiraBaseUrl + "/rest/api/latest/issue/" + issueKey + "?expand=names";
        ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.GET, entity, String.class);

        JsonNode rootNode = objectMapper.readTree(response.getBody());
        return storeCustomFieldValues(rootNode);
    }

    public Map<String, String> storeCustomFieldValues(JsonNode rootNode) {
        JsonNode fieldsNode = rootNode.path("fields");
        JsonNode namesNode = rootNode.path("names");

        // These lists contain the human-readable field names as shown in Jira
        List<String> simpleFieldNames = Arrays.asList("Summary", "Description");
        List<String> multiSelectFieldNames = Arrays.asList("Test Type");
        List<String> singleSelectFieldNames = Arrays.asList("Is Automated");

        Map<String, String> simpleMap = getCustomFieldId(namesNode, simpleFieldNames);
        Map<String, String> multiMap = getCustomFieldId(namesNode, multiSelectFieldNames);
        Map<String, String> singleMap = getCustomFieldId(namesNode, singleSelectFieldNames);

        Map<String, String> result = new HashMap<>();
        result.putAll(fetchSimpleTextFields(fieldsNode, simpleMap));
        result.putAll(fetchMultiSelectFields(fieldsNode, multiMap));
        result.putAll(fetchSingleSelectFields(fieldsNode, singleMap));

        return result;
    }

    private Map<String, String> getCustomFieldId(JsonNode namesNode, List<String> fieldNames) {
        Map<String, String> fieldMap = new HashMap<>();
        namesNode.fields().forEachRemaining(entry -> {
            String name = entry.getValue().asText();
            if (fieldNames.contains(name)) {
                fieldMap.put(name, entry.getKey()); // name -> customfield_xx
            }
        });
        return fieldMap;
    }

    private Map<String, String> fetchSimpleTextFields(JsonNode fieldsNode, Map<String, String> fieldMap) {
        Map<String, String> result = new HashMap<>();
        fieldMap.forEach((name, id) -> {
            String value = fieldsNode.path(id).asText(null);
            if (value != null) result.put(name, value);
        });
        return result;
    }

    private Map<String, String> fetchMultiSelectFields(JsonNode fieldsNode, Map<String, String> fieldMap) {
        Map<String, String> result = new HashMap<>();
        fieldMap.forEach((name, id) -> {
            JsonNode arrayNode = fieldsNode.path(id);
            if (arrayNode.isArray()) {
                List<String> values = new ArrayList<>();
                for (JsonNode item : arrayNode) {
                    values.add(item.path("value").asText(""));
                }
                result.put(name, String.join(" ", values));
            }
        });
        return result;
    }

    private Map<String, String> fetchSingleSelectFields(JsonNode fieldsNode, Map<String, String> fieldMap) {
        Map<String, String> result = new HashMap<>();
        fieldMap.forEach((name, id) -> {
            JsonNode objectNode = fieldsNode.path(id);
            if (objectNode.isObject()) {
                result.put(name, objectNode.path("value").asText(""));
            }
        });
        return result;
    }
}