import java.security.Key;
import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
import java.util.Base64; // Correct Base64 encoder/decoder

// Assuming 'context' is some map-like object where you store results
// Assuming 'scanrUser' and 'pat' are Strings defined elsewhere
// Assuming 'sKey' is your AES key string (e.g., "ASDF1234ASDF1234")

public class MyEncryptionClass { // Or integrate into your existing class

    public static void main(String[] args) {
        // --- Dummy data for demonstration ---
        String sKey = "ASDF1234ASDF1234"; // Your 16-byte key
        String scanrUser = "john.doe"; // Your user identifier
        String pat = "MySecretPassword123"; // Your plaintext to encrypt

        // --- Context placeholder ---
        java.util.Map<String, Object> context = new java.util.HashMap<>();
        // --- End Dummy data ---

        // Your key creation
        Key key = new SecretKeySpec(sKey.getBytes(), "AES");

        try {
            Cipher c = Cipher.getInstance("AES");
            c.init(Cipher.ENCRYPT_MODE, key);

            byte[] encval = c.doFinal(pat.getBytes("UTF-8")); // Always specify charset for String.getBytes()

            // --- CRITICAL CORRECTION HERE ---
            // 1. Convert scanrUser and the delimiter to bytes
            byte[] userBytes = scanrUser.getBytes("UTF-8");
            byte[] delimiterBytes = ":".getBytes("UTF-8");

            // 2. Determine the total length for the combined array
            int totalLength = userBytes.length + delimiterBytes.length + encval.length;

            // 3. Create a new byte array large enough to hold all concatenated bytes
            byte[] combinedBytes = new byte[totalLength];

            // 4. Copy bytes into the combined array
            System.arraycopy(userBytes, 0, combinedBytes, 0, userBytes.length);
            System.arraycopy(delimiterBytes, 0, combinedBytes, userBytes.length, delimiterBytes.length);
            System.arraycopy(encval, 0, combinedBytes, userBytes.length + delimiterBytes.length, encval.length);

            // 5. Base64 encode the ENTIRE combined byte array
            String AuthCode = Base64.getEncoder().encodeToString(combinedBytes);

            context.put("authCode", AuthCode);
            System.out.println("AuthCode generated successfully: " + AuthCode);

            // --- How to decrypt and verify (for testing purposes) ---
            System.out.println("\n--- Decryption Test ---");
            byte[] decodedCombinedBytes = Base64.getDecoder().decode(AuthCode);

            // To separate, you need to know the original lengths or a delimiter that you can search for.
            // A simple way for ':' is to convert back to string, find the first ':', then split.
            // This assumes ':' doesn't appear in your encrypted data (which is usually safe due to Base64).
            String decodedString = new String(decodedCombinedBytes, "UTF-8");
            int firstColonIndex = decodedString.indexOf(":");
            if (firstColonIndex != -1) {
                String decodedUser = decodedString.substring(0, firstColonIndex);
                // Extract the Base64 part of the encrypted payload
                // The part after the first colon could still contain further colons
                String encryptedPart = decodedString.substring(firstColonIndex + 1);

                // Now, you need to extract the raw encrypted bytes from 'encryptedPart'
                // This is the tricky part if ':' appears within the encrypted data.
                // It's safer to store lengths or use a format like TLV (Type-Length-Value).

                // For simplicity assuming no ':' in the actual decrypted payload for now:
                // This assumes 'encryptedPart' is the actual encrypted data (not its toString() representation)
                // However, `encryptedPart` is just a string slice, not the original raw encrypted bytes.
                // The byte array concatenation approach above is correct for the encryption side.
                // For decryption, you'd need to re-parse the byte array, not the string.

                // A better approach for decryption would be:
                // 1. Decode AuthCode from Base64 to get combinedBytes back.
                // 2. Find the delimiter ':' within combinedBytes.
                // 3. Split combinedBytes into userBytes and encryptedPayloadBytes.
                // 4. Convert userBytes back to String.
                // 5. Decrypt encryptedPayloadBytes using the key.

                // Let's refine the decryption logic here based on the combinedBytes:
                Cipher decryptCipher = Cipher.getInstance("AES");
                decryptCipher.init(Cipher.DECRYPT_MODE, key);

                // Find the index of the delimiter bytes within the decodedCombinedBytes
                // This is more robust than string searching if ':' might appear in actual encrypted data (though unlikely for AES output)
                // A simpler string split works if you trust that the delimiter won't be part of the encrypted base64 string
                // Let's use the string approach for simplicity, but be aware of its limitations.
                int delimiterLen = ":".getBytes("UTF-8").length;
                byte[] decryptedUserBytes = new byte[firstColonIndex];
                System.arraycopy(decodedCombinedBytes, 0, decryptedUserBytes, 0, firstColonIndex);
                String decryptedUser = new String(decryptedUserBytes, "UTF-8");

                byte[] encryptedContentBytes = new byte[decodedCombinedBytes.length - firstColonIndex - delimiterLen];
                System.arraycopy(decodedCombinedBytes, firstColonIndex + delimiterLen, encryptedContentBytes, 0, encryptedContentBytes.length);

                byte[] finalDecryptedPayload = decryptCipher.doFinal(encryptedContentBytes);
                String finalDecryptedText = new String(finalDecryptedPayload, "UTF-8");


                System.out.println("Decrypted User: " + decryptedUser);
                System.out.println("Decrypted Payload: " + finalDecryptedText);

                if (decryptedUser.equals(scanrUser) && finalDecryptedText.equals(pat)) {
                    System.out.println("Decryption and parsing successful!");
                } else {
                    System.err.println("Decryption or parsing failed.");
                }


            } else {
                System.err.println("Delimiter ':' not found in decoded string.");
            }


        } catch (Exception e) {
            System.out.println("ERROR: FID Encryption Failed");
            e.printStackTrace(); // Print stack trace for debugging
        }
    }
}
