# Secure Email Delivery Approaches in a Strict Enterprise Network

When your Spring Boot app lives behind tight corporate firewalls and data must never stray outside your company perimeter, you have several on-prem or internal-only options for sending mail. Pick the one that best fits your existing infrastructure and security policies.

---

## 1. Corporate SMTP Relay + JavaMailSender

Configure Spring Boot’s `JavaMailSender` to talk to your internal SMTP relay (e.g. Exchange, Postfix, Sendmail cluster).

  
- application.yml snippet  
  ```yaml
  spring:
    mail:
      host: smtp.corp.local
      port: 587
      username: app-svc-user
      password: ${MAIL_PASSWORD}
      properties:
        mail.smtp.auth: true
        mail.smtp.starttls.enable: true
        mail.smtp.starttls.required: true
  ```  
- Code example  
  ```java
  @Service
  public class EmailService {
      private final JavaMailSender sender;
      public EmailService(JavaMailSender sender) {
          this.sender = sender;
      }
      public void send(String to, String subject, String htmlBody) throws MessagingException {
          MimeMessage msg = sender.createMimeMessage();
          MimeMessageHelper helper = new MimeMessageHelper(msg, true, "UTF-8");
          helper.setTo(to);
          helper.setSubject(subject);
          helper.setText(htmlBody, true);
          sender.send(msg);
      }
  }
  ```  
- Credentials  
  - Store username/password in Vault, Kubernetes Secrets or OpenShift’s encrypted ConfigMaps  
  - Rotate regularly and restrict permissions to “send only”  

| Pros                                    | Cons                                           |
|-----------------------------------------|------------------------------------------------|
| No external dependencies                | Relay must be highly available & maintained    |
| All traffic stays inside corporate LAN  | You manage deliverability and spam reputation  |
| Simple Spring Boot integration          | Limited analytics (no open/click tracking)     |

---

## 2. Internal Email-Sending Microservice (REST)

Build or reuse a small “email-gateway” service inside your DMZ that exposes a secure REST API. Your app calls it; the gateway handles SMTP or direct Exchange protocols.

- Benefits  
  - Centralizes mailbox credentials and retry logic  
  - Teams can enforce common templates, headers, DKIM signatures  
- Security  
  - Protect API with OAuth2/JWT or mTLS  
  - Audit every email request in a centralized log  

---

## 3. Microsoft Graph API or Exchange Web Services (EWS)

If your company uses Office 365 or on-prem Exchange and allows API access, call Graph or EWS over HTTPS with OAuth2.

  
- Spring integration  
  - Use MS Graph SDK or plain `WebClient`  
  - Acquire token via client credentials (Azu­re AD)  
- Example  
  ```java
  graphClient.users(userId)
    .sendMail(message, true)
    .buildRequest()
    .post();
  ```  
- Pros  
  - Leverages corporate mailboxes and shared calendars  
  - Supports rich attachments, high throughput  
- Cons  
  - Requires AD app registration & token management  
  - Must whitelist Graph endpoints in firewall  

---

## 4. Enterprise Message Bus (JMS/Kafka) → Mail Handler

Publish email requests to your corporate message bus; a downstream consumer (owned by IT or another team) picks them up and sends mail.

- Workflow  
  1. App writes email event to JMS topic or Kafka  
  2. Mail handler service subscribes, formats, and pushes to SMTP  
- Advantages  
  - Decouples your app from mail infra changes  
  - Built-in retry, dead-letter for failures  

---

## 5. Self-Hosted SMTP Sidecar in OpenShift

Deploy a lightweight SMTP relay (e.g. Postfix container) alongside your app pod. It forwards to your corporate mail farm over a secured tunnel or VPN.

- Setup  
  - Sidecar container listens on localhost:25  
  - App points `spring.mail.host: localhost`  
  - Relay is preconfigured with SMTPS and auth to corporate SMTP  
- Pros  
  - App never touches credentials directly  
  - Network egress stays entirely within cluster/VPN  
- Cons  
  - More moving parts to maintain  
  - Sidecar resource overhead  

---

## Advanced Best Practices

- Always enforce TLS for SMTP or API calls  
- Use asynchronous sending (`@Async`, task executors, or queue consumers)  
- Template your emails with Thymeleaf or FreeMarker for consistency  
- Centralize and audit all outbound messages  
- Monitor delivery metrics (success/failures) via logs or your mail gateway  

---

Which of these fits best with your current network topology and corporate policies? Let me know, and I can share concrete configuration examples or orchestration templates for OpenShift.