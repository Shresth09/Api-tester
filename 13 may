public Map<String, String> buildFilteredTaMap(Map<String, String> taDataMap) {
    Map<String, String> refinedMap = new HashMap<>();

    // Only include non-null, non-empty values
    taDataMap.forEach((key, value) -> {
        if (value != null && !value.isBlank()) {
            switch (key) {
                case "architect_soeid":
                case "asa_override_appr_soeid":
                    if (verifyJiraUser(value)) {
                        refinedMap.put(key, value);
                    }
                    break;

                case "asa_architectural_significance":
                    String lower = value.trim().toLowerCase();
                    if ("yes".equals(lower)) {
                        refinedMap.put(key, "Architecturally Significant");
                    } else if ("no".equals(lower)) {
                        refinedMap.put(key, "Not Architecturally Significant");
                    }
                    break;

                case "asa_status":
                    refinedMap.put(key, value.replace(" ", "-"));
                    break;

                default:
                    refinedMap.put(key, value);
                    break;
            }
        }
    });

    return refinedMap;
}





Perfect, Shresth. Here's how you can extract those custom field IDs from the `names` object in the JIRA response and return a `Map<String, String>` that maps field names to their corresponding custom field IDs:

### âœ… Method to Extract Field ID Map
```java
public Map<String, String> extractCustomFieldIdMap(JsonNode jiraResponse) {
    Map<String, String> fieldIdMap = new HashMap<>();

    // These are the friendly field names we're looking for
    Set<String> targetFields = Set.of(
        "Planview ID",
        "ASA: Approval Date",
        "ASA: Architect SOEID",
        "ASA: Override Request Date",
        "ASA: Override Decision Date",
        "ASA: Override Approver SOEID",
        "ASA: Architectural Significance",
        "ASA: Status"
    );

    JsonNode namesNode = jiraResponse.path("names");

    if (!namesNode.isMissingNode()) {
        Iterator<Map.Entry<String, JsonNode>> fields = namesNode.fields();

        while (fields.hasNext()) {
            Map.Entry<String, JsonNode> entry = fields.next();
            String fieldId = entry.getKey(); // e.g., "customfield_12345"
            String fieldName = entry.getValue().asText(); // e.g., "Planview ID"

            if (targetFields.contains(fieldName)) {
                fieldIdMap.put(fieldName, fieldId);
            }
        }
    }

    return fieldIdMap;
}
```

### ðŸ“Œ Usage Example (inside `processTaInput`)
Once you get the JIRA response:
```java
Map<String, String> customFieldMap = extractCustomFieldIdMap(response.getBody());
```

Let me know if youâ€™d like to log missing fields for diagnostics or reverse-map the `fieldId -> label` instead. We can flex this logic easily depending on how you're consuming it downstream!