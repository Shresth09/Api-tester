Perfect, Shresth. Here's how you can extract those custom field IDs from the `names` object in the JIRA response and return a `Map<String, String>` that maps field names to their corresponding custom field IDs:

### âœ… Method to Extract Field ID Map
```java
public Map<String, String> extractCustomFieldIdMap(JsonNode jiraResponse) {
    Map<String, String> fieldIdMap = new HashMap<>();

    // These are the friendly field names we're looking for
    Set<String> targetFields = Set.of(
        "Planview ID",
        "ASA: Approval Date",
        "ASA: Architect SOEID",
        "ASA: Override Request Date",
        "ASA: Override Decision Date",
        "ASA: Override Approver SOEID",
        "ASA: Architectural Significance",
        "ASA: Status"
    );

    JsonNode namesNode = jiraResponse.path("names");

    if (!namesNode.isMissingNode()) {
        Iterator<Map.Entry<String, JsonNode>> fields = namesNode.fields();

        while (fields.hasNext()) {
            Map.Entry<String, JsonNode> entry = fields.next();
            String fieldId = entry.getKey(); // e.g., "customfield_12345"
            String fieldName = entry.getValue().asText(); // e.g., "Planview ID"

            if (targetFields.contains(fieldName)) {
                fieldIdMap.put(fieldName, fieldId);
            }
        }
    }

    return fieldIdMap;
}
```

### ðŸ“Œ Usage Example (inside `processTaInput`)
Once you get the JIRA response:
```java
Map<String, String> customFieldMap = extractCustomFieldIdMap(response.getBody());
```

Let me know if youâ€™d like to log missing fields for diagnostics or reverse-map the `fieldId -> label` instead. We can flex this logic easily depending on how you're consuming it downstream!