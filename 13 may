
package com.immersivelabs.forum.utils;

import jakarta.servlet.http.HttpSession;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
// Removed unused import: import jakarta.servlet.http.Cookie;
import com.immersivelabs.forum.model.User;
// Removed unused import: import com.immersivelabs.forum.repository.UserRepository;

public class UserUtils {

    /**
     * Retrieves the logged-in User object from the server-side session.
     * @param req The current HttpServletRequest.
     * @return The logged-in User object, or null if not logged in.
     */
    public static User getUser (HttpServletRequest req) {
        // TODO: Get the user object from the "user" attribute in the session
        HttpSession session = req.getSession(false); // Do not create a new session if one doesn't exist
        if (session != null) {
            return (User) session.getAttribute("user");
        }
        return null;
    }

    /**
     * Logs in a user by invalidating any existing session and storing the User object securely in a new session.
     * @param req The current HttpServletRequest.
     * @param resp The current HttpServletResponse (unused for session-based login, but kept for method signature).
     * @param user The User object to log in.
     */
    public static void login(HttpServletRequest req, HttpServletResponse resp, User user) {
        HttpSession session = req.getSession(false); // Get existing session if one exists
        
        // Security best practice: Invalidate old session on successful login to prevent Session Fixation.
        if (session != null) {
            session.invalidate();
        }

        session = req.getSession(true); // Create a new, secure session
        
        // TODO: Add the user to the session under the "user" attribute
        session.setAttribute("user", user);
    }

    /**
     * Logs out the current user by invalidating their server-side session.
     * @param req The current HttpServletRequest.
     * @param resp The current HttpServletResponse (unused, but kept for method signature).
     */
    public static void logout(HttpServletRequest req, HttpServletResponse resp) {
        HttpSession session = req.getSession(false);
        if (session != null) {
            session.invalidate();
        }
    }
    
    /*
    // VULNERABLE CODE DELETED: lines 33-77 that saved user ID to a client-side cookie.
    */
}








This is a great exercise in identifying and mitigating a common security vulnerability. I can help you with the analysis and the defensive code rewrite, focusing on secure practices and education.
1. üîç Identifying the Command Injection Vulnerability
The command injection vulnerability exists within the getCurrentDate method in SettingsServlet.java:
public static String getCurrentDate(String format){
    return execCmd(new String[]{"/bin/sh", "-c", "date +'"+format+"'"}).strip();
}

The user-controlled input, format (the date format string), is concatenated directly into a shell command that is executed via execCmd.
 * Vulnerable Code: execCmd(new String[]{"/bin/sh", "-c", "date +'"+format+"'"})
 * Source of Input: The format variable is derived from the date_format request parameter, which is controllable by an attacker.
 * The Attack: An attacker can inject arbitrary shell commands by closing the single quote ('), adding a command separator (like a semicolon ; or a pipe |), and then adding their malicious command.
   * Example Payload: An attacker could set the date_format to: ' ; cat /etc/passwd #
   * Resulting Command (executed by the shell): date +'' ; cat /etc/passwd #'
     * The first single quote closes the one before format.
     * The semicolon separates the commands.
     * The malicious command (cat /etc/passwd) is executed.
     * The hash (#) comments out the rest of the original command, preventing syntax errors.
This is a critical vulnerability that allows for Remote Code Execution (RCE).
2. üõ°Ô∏è Rewriting getCurrentDate with DateFormat
To eliminate the command injection vulnerability, we'll rewrite getCurrentDate to use safe, built-in Java date/time libraries (java.text.SimpleDateFormat and java.util.Date) instead of calling an external shell command.
Here is the secure, rewritten code for SettingsServlet.java:
import java.text.DateFormat; // Necessary import
import java.text.SimpleDateFormat; // Necessary import
import java.util.Date; // Necessary import
// ... other imports

// We can remove the execCmd method as it's no longer needed for this functionality
// public static String execCmd(String[] cmd) { ... } 

// Update the parameter (now the format is a standard SimpleDateFormat string)
public static String getCurrentDate(String formatString){
    // 1. Create a Date object for the current time
    Date now = new Date();
    
    // 2. Create a SimpleDateFormat object with the provided format string
    // This safely formats the date *within* the Java environment.
    try {
        DateFormat dateFormat = new SimpleDateFormat(formatString);
        
        // 3. Format the date and return the string
        return dateFormat.format(now);
    } catch (IllegalArgumentException e) {
        // Handle cases where the user provides an invalid format string (best practice)
        // Log the error and fall back to a safe, default format
        System.err.println("Invalid date format provided: " + formatString);
        DateFormat defaultFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        return defaultFormat.format(now) + " (Error: Invalid Format)";
    }
}

Note on Format Strings: The format strings for the shell date command (e.g., %Y-%m-%d) are different from the format strings used by Java's SimpleDateFormat (e.g., yyyy-MM-dd). The new format strings for SimpleDateFormat are:
| Shell Format (date) | Java Format (SimpleDateFormat) | Output Format |
|---|---|---|
| %Y-%m-%d %H:%M:%S | yy-MM-dd HH:mm:ss | 25-11-25 13:34:59 |
| %d-%m-%y %H:%M:%S | dd-MM-yy HH:mm:ss | 25-11-25 13:34:59 |
| %m-%d-%y %H:%M:%S | MM-dd-yy HH:mm:ss | 11-25-25 13:34:59 |
3. & 4. ‚úçÔ∏è Updating settings.jsp
We need to open src/main/webapp/WEB-INF/jsp/settings.jsp and update the <option> values in the <select> element to use the correct Java SimpleDateFormat format strings.
The original JSP code:
<select id="date_format" name="date_format">
    <option value="%Y-%m-%d %H:%M:%S">year-month-day</option>
    <option value="%d-%m-%y %H:%M:%S">day-month-year</option>
    <option value="%m-%d-%y %H:%M:%S">month-day-year</option>
</select><br/><br/>

The updated JSP code:
<select id="date_format" name="date_format">
    <option value="yy-MM-dd HH:mm:ss">year-month-day</option>
    <option value="dd-MM-yy HH:mm:ss">day-month-year</option>
    <option value="MM-dd-yy HH:mm:ss">month-day-year</option>
</select><br/><br/>

Summary of Changes
 * Vulnerability: Command injection was in getCurrentDate via external date command execution.
 * Mitigation: getCurrentDate was rewritten using SimpleDateFormat and Date to perform date formatting securely within Java.
 * Update: The values in settings.jsp were updated to use the corresponding Java date format strings (yy-MM-dd HH:mm:ss, etc.) for compatibility with the new, secure Java function.
Would you like me to explain more about the differences between Java's date formatting and the shell's date command formatting?
